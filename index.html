<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>reveal.js</title>
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <link rel="stylesheet" href="css/overrides.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h3 class="em1">Spring Cloud Stream</h3>
            <img height="40%" data-src="https://spring.io/img/homepage/icon-spring-cloud.svg"
                 alt="Down arrow">
            <p>
                Spring Cloud Stream is a framework for building highly scalable event-driven microservices
                connected with shared messaging systems.
            </p>
        </section>
        <section>
            <section>
                <h3 class="em1">先談一下 Spring</h3>
            </section>
            <section>
                <p class="em2">Spring Design Philosophy</p>
                <p>Provide choice at every level. Spring lets you defer design decisions as late as possible. For
                    example, you can switch persistence providers through configuration without changing your code. The
                    same is true for many other infrastructure concerns and integration with third-party APIs.</p>
                <aside class="notes">
                    提供各個層面的選擇。 Spring允許您盡可能晚地推遲設計決策。 例如，您可以通過配置切換持久性提供程序，而無需更改代碼。 許多其他基礎架構問題以及與第三方API的集成也是如此。
                </aside>
                <p>
                    <small>
                        <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy">
                            https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">實際經驗</p>
                <p>在 NoSQL 異軍突起的年代</p>
                <p>同時要開發 MongoDB, Elasticsearch 數據操作</p>
                <p>還有原本的 RMDB</p>
                <p>一樣是 CRUD 你就必須使用不同 SDK 不同的 API</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/P5AtQNV.jpg" alt="絕望">
            </section>
            <section>
                <p class="em2">Spring Data 出現後</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">JPA</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                        @Entity
                        public class Order{
                            @Id private String orderId;
                            private String billingAddress;
                            private String shippingAddress;
                        }
                    </code>
                    <code class="java" data-trim contenteditable>
                        public interface OrderRepository
                            extends PagingAndSortingRepository< Order, Long > {}
                    </code>
                </pre>
            </section>
            <section>
                <p class="em2">MongoDB</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                        @Document
                        public class Order {
                            @Id private String orderId;
                            private String billingAddress;
                            private String shippingAddress;
                        }
                    </code>
                    <code class="java" data-trim contenteditable>
                        public interface OrderRepository
                            extends PagingAndSortingRepository< Order, Long > {}
                    </code>
                </pre>
            </section>
            <section>
                <p class="em2">Elasticsearch</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                        @Document(indexName = "ec", type = "order")
                        public class Order {
                            @Id private String orderId;
                            private String billingAddress;
                            private String shippingAddress;
                        }
                    </code>
                    <code class="java" data-trim contenteditable>
                        public interface OrderRepository
                            extends PagingAndSortingRepository< Order, Long > {}
                    </code>
                </pre>
            </section>
            <section>
                <p>從此之後我取資料的 API 就只有一種</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                       OrderRepository.getOne()
                    </code>
                </pre>
            </section>
            <section data-background="http://i.giphy.com/90F8aUepslB84.gif">
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">Message Queue</h3>
                <p>訊息佇列是一種行程間通訊或同一行程的不同執行緒間的通訊方式，軟體的貯列用來處理一系列的輸入，通常是來自使用者。</p>
            </section>
            <section>
                <h3 class="em2">Message Queue 有哪些?</h3>
                <p>Apache Kafka, RabbitMQ, Apache ActiveMQ, ZeroMQ, Apache RocketMQ(阿里), Redis, MQTT</p>
            </section>
            <section>
                <p><span>你以為很多了嗎?</span></p>
                <h1><span class="fragment em2" style="font-size: 300px">不</span></h1>
            </section>
            <section>
                <h3 class="em2">還有雲端服務</h3>
                <p>Amazon Kinesis, Google PubSub, Solace PubSub+, Azure Event Hubs</p>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">設計理念不同</h3>
                <p>Kafka 適合做大量 log 收集</p>
                <p>RabbitMQ 中庸 好架設 可以用作聊天系統</p>
                <p>RocketMQ 有保證抵達順序 可以用作交易系統</p>
            </section>
            <section>
                <p class="em2">RabbitMQ</p>
                <p>
                    <small>Topics</small>
                </p>
                <img data-src="https://www.rabbitmq.com/img/tutorials/python-five.png"
                     style="background-color: white"
                     alt="RabbitmqTopics">
                <p>
                    <small>任何發送到 Topic Exchange 的消息都會被轉發到所有關心 RouteKey 中指定話題的 Queue 上</small>
                </p>
                <p>
                    <small>
                        <a href="https://www.rabbitmq.com/getstarted.html">
                            https://www.rabbitmq.com/getstarted.html
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">Kafka</p>
                <img data-src="https://kafka.apache.org/21/images/consumer-groups.png"
                     style="background-color: white"
                     alt="Kafka">
                <p>
                    <small>
                        If all the consumer instances have the same consumer group, then the records will effectively be
                        load balanced over the consumer instances.
                    </small>
                </p>
                <p>
                    <small>
                        <a href="https://kafka.apache.org/documentation/#intro_consumers">
                            https://kafka.apache.org/documentation/#intro_consumers
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">RocketMQ</p>
                <img data-src="https://i.imgur.com/VWMQy8r.png" height="300px"
                     style="background-color: white"
                     alt="RocketMQ">
                <p>
                    <small>
                        用来表示一个消费消息应用，一个Consumer Group下包含多个Consumer实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个Consumer对象。一个Consumer
                        Group下的多个Consumer以均摊方式消费消息，如果设置为广播方式，那么这个Consumer Group下的每个实例都消费全量数据。
                    </small>
                </p>
                <p>
                    <small>
                        <a href="http://flycloud.me/2017/12/04/rocketMQ/rocketMQ%E5%AD%A6%E4%B9%A0/RocketMQ%E5%9F%BA%E7%A1%80/">
                            RocketMQ开发指南
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <h4>假設需要同時使用</h4>
            </section>
            <section>
                <p>但是這三套並不相容, 套件用法也各有不同</p>
                <p>所以你必須同時搞懂三套的 API 用法</p>
                <table>
                    <thead>
                    <tr>
                        <th>MQ</th>
                        <th>Protocol</th>
                        <th>Library</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Kafka</td>
                        <td>自訂RPC</td>
                        <td>kafka-clients-2.1.0.jar</td>
                    </tr>
                    <tr>
                        <td>RabbitMQ</td>
                        <td>AMQP</td>
                        <td>amqp-client-5.5.1.jar</td>
                    </tr>
                    <tr>
                        <td>RocketMQ</td>
                        <td>JMS, MQTT</td>
                        <td>rocketmq-client-4.3.2.jar</td>
                    </tr>
                    </tbody>
                </table>
                <aside class="notes">
                </aside>
            </section>
            <section data-background="https://media.giphy.com/media/YpmVBNubONoqs/giphy.gif">
            </section>
            <section>
                <p>不用再頭痛了</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>要來講 <span class="em2">Spring Cloud Stream</span> 了</p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">Spring Cloud Stream</h3>
                <p>功能與目的 跟 Spring Data 一樣, 由 Spring 來提供更高一階操作, 由各家來實現, 來達成減少我們開發成本.</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Spring Cloud Stream</p>
                <p>
                    <small>The core building blocks of Spring Cloud Stream are:</small>
                </p>
                <ul>
                    <small>
                        <li>Destination Binders: Components responsible to provide integration with the external
                            messaging systems.
                        </li>
                        <li>Destination Bindings: Bridge between the external messaging systems and application provided
                            Producers and Consumers of messages (created by the Destination Binders).
                        </li>
                        <li>Message: The canonical data structure used by producers and consumers to communicate with
                            Destination Binders (and thus other applications via external messaging systems).
                        </li>
                    </small>
                    <p>
                        <small>
                            <a href="https://cloud.spring.io/spring-cloud-stream/">
                                https://cloud.spring.io/spring-cloud-stream/
                            </a>
                        </small>
                    </p>
                </ul>
                <aside class="notes">
                    <p>目標綁定器：負責提供與外部消息傳遞系統集成的組件。</p>
                    <p>目標綁定：外部消息傳遞系統和應用程序之間的橋接消息的生產者和消費者（由目標綁定器創建）。</p>
                    <p>消息：生產者和使用者使用的規範數據結構與目標綁定器（以及通過外部消息傳遞系統的其​​他應用程序）進行通信。</p>
                </aside>
            </section>
            <section>
                <img data-src="https://cloud.spring.io/spring-cloud-stream/img/SCSt-overview.png" height="300px"
                     style="background-color: white"
                     alt="SCSt">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Binder Implementations</p>
                <p>
                    <small>
                        Spring Cloud Stream supports a variety of binder implementations and the following table
                        includes the link to the GitHub projects.
                    </small>
                </p>
                <p>RabbitMQ</p>
                <p>Apache Kafka</p>
                <p>Amazon Kinesis</p>
                <p>Google PubSub (partner maintained)</p>
                <p>Solace PubSub+ (partner maintained)</p>
                <p>Azure Event Hubs (partner maintained)</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>2018.11.16「小马哥技术周报」- 第八期 Spring Cloud Stream Binder Alibaba 实现</p>
                <img data-src="https://i.imgur.com/dgNQ8Zg.png" alt="RocketMQ">
                <p>
                    <small>
                        <a href="https://www.bilibili.com/video/av36114167">
                            bilibili視頻
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">Spring Cloud Stream</h3>
                <p class="em2">sample code</p>
            </section>
            <section>
                <p>dependency</p>
                <pre><code class="xml" data-trim contenteditable>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
        </dependency>
    </dependencies>
                </code></pre>
            </section>
            <section>
                <p class="em2">Producer</p>
            </section>
            <section>
                <p>Producer - application.yml</p>
                <pre><code class="yaml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:    # 因為啟動會發生錯誤, 所以不需要預設的 RabbitTemplate
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        output:    # channelName
          destination: chat.message.v1    # destination，或者可以認為是發布－訂閱模型裏面的topic
          content-type: application/json
          binder: eventMq    # 綁定使用的binder
      binders:
        eventMq:
          type: rabbit    # 要使用的 MQ 系統 kafka or 其他等等
          environment:
            spring:
              rabbitmq:
                host: 192.168.56.101
                port: 5672
                </code></pre>
            </section>
            <section>
                <p class="em2">Source.java</p>
                <pre><code class="java" data-trim contenteditable>
package org.springframework.cloud.stream.messaging;

/**
 * Bindable interface with one output channel.
 *
 * @see org.springframework.cloud.stream.annotation.EnableBinding
 * @author Dave Syer
 * @author Marius Bogoevici
 */
public interface Source {

	String OUTPUT = "output";

	@Output(Source.OUTPUT)
	MessageChannel output();

}
                </code></pre>
                <p>
                    <small>
                        <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/messaging/Source.java">
                            Github
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">Producer - DemoApplication.java</p>
                <pre><code class="java" data-trim contenteditable>
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;

@EnableBinding(Source.class)
@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
                </code></pre>
            </section>

            <section>
                <p class="em2">發送消息</p>
                <pre><code class="java" data-trim contenteditable>
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;

@Component
public class ApplicationLoader {
    @Autowired
    private Source source;

    @EventListener(ApplicationReadyEvent.class)
    public void init() {
        Message< String > message = MessageBuilder.withPayload("Hi!!")
                    .build();
        source.output().send(message);
    }
}
                </code></pre>
            </section>
            <section>
                <p class="em2">Consumer</p>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:    # channelName
          destination: chat.message.v1
          content-type: application/json
          binder: eventMq
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 192.168.56.101
                port: 5672
                </code></pre>
                <p>channelName 不一樣</p>
                <aside class="notes">
                    提醒一下 channelName 不一樣
                </aside>
            </section>
            <section>
                <p>Sink.java</p>
                <pre><code class="java" data-trim contenteditable>
package org.springframework.cloud.stream.messaging;

/**
 * Bindable interface with one input channel.
 *
 * @see org.springframework.cloud.stream.annotation.EnableBinding
 * @author Dave Syer
 * @author Marius Bogoevici
 */
public interface Sink {

	String INPUT = "input";

	@Input(Sink.INPUT)
	SubscribableChannel input();

}
                </code></pre>
                <p>
                    <small>
                        <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/messaging/Sink.java">
                            Github
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">接收消息</p>
                <pre><code class="java" data-trim contenteditable>
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Component;

@Component
public class ChatReceiver {

    @StreamListener(target = Sink.INPUT)
    public void chatReceive(Message< String > chatMessage) {
        System.out.println("收到: " + chatMessage.getPayload());
    }
}
                </code></pre>
            </section>
            <section>
                <p>測試一下</p>
            </section>
            <section>
                <img data-src="https://i.imgur.com/YwBtOZY.png" alt="測試結果">
            </section>
            <section>
                <h3 class="em2">Done!</h3>
                <img data-src="https://i.imgur.com/viKySyO.jpg" alt="興奮到模糊">
            </section>
            <section>
                <p class="em2">說明一下 Spring 做了什麼</p>
                <aside class="notes">
                </aside>
            </section>

            <section>
                <p class="em2">Exchanges</p>
                <img data-src="https://i.imgur.com/F6gHn6T.png" alt="RabbitMQ Exchanges">
                <aside class="notes">
                    由 Spring 自動建立 Exchange, 也就是我們 yaml 的 destination
                </aside>
            </section>
            <section>
                <p class="em2">Bindings</p>
                <img data-src="https://i.imgur.com/IDht9LV.png" alt="RabbitMQ Bindings">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Queues</p>
                <img data-src="https://i.imgur.com/RHotRbr.png" alt="RabbitMQ Queues">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/fW6obUN.png" style="background-color: white" alt="RabbitMQ Queues">
                <p>Queue chat.message.v1.anonymous.SD0R-ebmRUqPjI-BZsX9Vg 在服務停止後會移除</p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">But</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>人生最厲害就是這個 BUT ！</p>
                <img data-src="https://www.books.com.tw/img/001/048/39/0010483921.jpg" alt="多個 Consumer">
                <p>
                    <small>
                        <a href="https://www.books.com.tw/products/0010483921">
                            博客來-人生最厲害就是這個 BUT！
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>多個 Consumer</p>
                <img data-src="https://i.imgur.com/F75LT8U.png" alt="多個 Consumer">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://dvblobcdnjp.azureedge.net//Content/Upload/Popular/Images/2017-06/e99e6b5e-ca6c-4c19-87b7-dfd63db6381a_m.jpg"
                     width="60%" alt="黑人問號">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>重複消費問題</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>問題出在</p>
                <img data-src="https://i.imgur.com/28DXlKl.png" alt="兩個Queue">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/VWdm8s6.png" alt="Exchange到兩個Queue">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/Dx3ydmC.png" style="background-color: white" alt="結構圖">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Spring cloud stream 的解決方法</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Consumer Groups</p>
                <p>
                    <small>
                        While the publish-subscribe model makes it easy to connect applications through shared
                        topics, the ability to scale up by creating multiple instances of a given application is equally
                        important. When doing so, different instances of an application are placed in a competing
                        consumer relationship, where only one of the instances is expected to handle a given message.
                    </small>
                </p>
                <p>
                    <small>
                        Spring Cloud Stream models this behavior through the concept of a consumer group. (Spring
                        Cloud Stream consumer groups are similar to and inspired by Kafka consumer groups.) Each
                        consumer binding can use the spring.cloud.stream.bindings.< channelName >.group property to
                        specify a group name. For the consumers shown in the following figure, this property would be
                        set as spring.cloud.stream.bindings.< channelName >.group=hdfsWrite or
                        spring.cloud.stream.bindings.< channelName >.group=average.
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/images/SCSt-groups.png"
                     alt="spring 解法">
                <p>
                    <small>
                        <a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#consumer-groups">
                            https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#consumer-groups
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:
          destination: chat.message.v1
          content-type: application/json
          group: chatGroup                      # 綁定消費組
          binder: eventMq
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 127.0.0.1
                port: 5672
                </code></pre>
                <p>綁定 group</p>
                <aside class="notes">
                    group
                </aside>
            </section>
            <section>
                <h3 class="em2">Done!</h3>
                <img data-src="https://i.imgur.com/ELCpI4x.png" alt="嚇得我目瞪口呆">
            </section>
            <section>
                <p>Exchange</p>
                <img data-src="https://i.imgur.com/zmWEX8K.png" alt="Exchange">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Queue</p>
                <img data-src="https://i.imgur.com/vh6lK9G.png" width="60%" alt="Exchange">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/wGGVIrd.png" style="background-color: white" alt="結構圖">
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">其他功能</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>例如</p>
                <p>重試 死信</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  application:
    name: gameservice-v1
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        gameChannel:
          destination: game.create.message.v1    # destination，或者可以認為是發布－訂閱模型裏面的topic
          content-type: application/json
          group: gameGroup    # 綁定消費組
          consumer:
            max-attempts: 3    # 默認為 3 次，1 表示禁用重試
          binder: eventMq
        resultChannel:
          destination: result.message
          content-type: application/json
          producer:
            required-groups: webGroup, resultGroup    # 預先建立的 group, 以免消息流失
          binder: eventMq
      binders:
        eventMq:
          type: rabbit    # rabbit or kafka
          environment:
            spring:
              rabbitmq:
                host: 192.168.56.101
                port: 5672
      rabbit:
        bindings:
          gameChannel:
            producer:
              auto-bind-dlq: true
#              dead-letter-exchange: sam.test
            consumer:
              auto-bind-dlq: true    # 建立 Exchange: DLX
#              dead-letter-exchange: sam.test    # 死信指定的 Exchange Name
              republish-to-dlq: true    # 該值為false如果設置了死信隊列，消息對原封不動的發送到死信隊列，如果為true，則消息對帶上錯誤信息發送至死信隊列
#              dlq-ttl: 10000     # 存活時間(毫秒)
                </code></pre>
                <aside class="notes">
                    auto-bind-dlq 記得兩邊都要配置
                </aside>
            </section>
            <section>
                <p>DLX</p>
                <img data-src="https://i.imgur.com/UrH4kI9.png" style="background-color: white" alt="DLX結構圖">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>重試結果</p>
                <img data-src="https://i.imgur.com/aUOMkeV.png" alt="retry">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>republish-to-dlq=true</p>
                <img data-src="https://i.imgur.com/wApU9GC.png" width="50%" alt="retry">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>game.create.message.v1.gameGroup.dlq</p>
                <img data-src="https://i.imgur.com/AAZVnzc.pngg" width="200%" alt="retry">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>死信接收</p>
                <pre><code class="java" data-trim contenteditable>
@Slf4j
@Component
public class DlqResultReceiverAmqp {
    private static final String ORIGINAL_QUEUE = "game.create.message.v1.gameGroup";
    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    @RabbitListener(queues = DLQ)
    public void receiveDLQResult(Message failedMessage) {
        log.info("amqp spanTraceId={}", headers.get("spanTraceId"));
        log.info("amqp spanId={}", headers.get("spanId"));
        log.info("amqp x-exception-message={}", headers.get("x-exception-message"));
        log.info("amqp x-exception-stacktrace={}", headers.get("x-exception-stacktrace"));
        String messageBody = new String(failedMessage.getBody());
        log.info("amqp messageBody={}", messageBody);
    }
}
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>死信接收 使用 ServiceActivator </p>
                <a href="https://mp.weixin.qq.com/s/7sILItNKJ_i9bCZ68vhErg">
                    程序猿DD - Spring Cloud Stream消费失败后的处理策略（二）：自定义错误处理逻辑
                </a>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>監控</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>加入</p>
                <pre><code class="xml" data-trim contenteditable>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>開啟監控 application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
management:
  health:
    binders:
      enabled: true
  endpoints:
    web:
      exposure:
        include: 'channels,bindings,bindings-name'
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>取得 channels 資訊</p>
                <pre><code class="curl" data-trim contenteditable>
curl -X GET http://localhost:7203/actuator/channels
                </code></pre>
                <p></p>
                <pre><code class="json" data-trim contenteditable>
{
    "inputs": {
        "gameChannel": {
            "destination": "game.create.message.v1",
            "group": "gameGroup",
            "binder": "eventMq",
            "consumer": {
                "instanceCount": 1,
                "instanceIndex": 0,
                "maxAttempts": 1
            }
        }
    },
    "outputs": {
        "resultChannel": {
            "destination": "result.message",
            "binder": "eventMq",
            "producer": {
                "requiredGroups": [
                    "webGroup",
                    "resultGroup"
                ]
            }
        }
    }
}
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>鏈路追蹤</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>加入</p>
                <pre><code class="xml" data-trim contenteditable>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-sleuth</artifactId>
        </dependency>
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>取得 spanTraceId</p>
                <pre><code class="java" data-trim contenteditable>
    @StreamListener(target = MqChannel.gameChannel)
    @SendTo(MqChannel.resultChannel)
    public Message< ResponseData> receiveGameCreateEvent(
            Message GameCreateEvent> eventMessage) {
        log.info("Message spanTraceId={}", eventMessage.getHeaders().get("spanTraceId"));
        log.info("Message spanId={}", eventMessage.getHeaders().get("spanId"));
        ResponseData responseData = new ResponseData()
                .setEventId(gameCreateEvent.getEventId()).setCode("0")
                .setMessage(gameCreateEvent.getGameName() + " 創建帳號已完成");
        return MessageBuilder.withPayload(responseData)
                .setHeader("username", username)
                .build();
    }
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>取得 spanTraceId 結果</p>
                <pre><code class="shell" data-trim contenteditable>
2018-12-17 11:31:59.718  INFO [gameservice-v1,2fff644a3967a533,868d7e1a8ca99ff0,false] 2052 --- [.v1.gameGroup-1]
                    c.e.demo.consumer.GameEventReceiver      : Message spanTraceId=2fff644a3967a533
2018-12-17 11:31:59.719  INFO [gameservice-v1,2fff644a3967a533,868d7e1a8ca99ff0,false] 2052 --- [.v1.gameGroup-1]
                    c.e.demo.consumer.GameEventReceiver      : Message spanId=63a6cfa6e68c0253
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>使用 Condition</p>
                <pre><code class="java" data-trim contenteditable>
    @StreamListener(target = Processor.INPUT, condition = "headers['eventType']=='gameCreate'")
    public void createGamePlus(
            @Header(name = "username", required = false) String username,
            Message< ResponseData > eventMessage) {
        ResponseData responseDataToWeb = new ResponseData()
                .setCode("0")
                .setMessage(responseData.getGameName() + ", 歡迎 VIP 馬上充值 送好禮!!")
                .setDateTime(LocalDateTime.now());
        Message< ResponseData > responseDataMessage = MessageBuilder.withPayload(responseDataToWeb)
                .setHeader("username", username)
                .build();
    }
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>測試</p>
                <p>
                    <small>可不依賴 RabbitMQ 進行測試</small>
                </p>
                <pre><code class="java" data-trim contenteditable>
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ExampleTest {

  @Autowired
  private Processor processor;

  @Autowired
  private MessageCollector messageCollector;

  @Test
  @SuppressWarnings("unchecked")
  public void testWiring() {
    Message< String> message = new GenericMessage<>("hello");
    processor.input().send(message);
    Message< String> received = (Message< String>) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo("hello world"));
  }


  @SpringBootApplication
  @EnableBinding(Processor.class)
  public static class MyProcessor {

    @Autowired
    private Processor channels;

    @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
    public String transform(String in) {
      return in + " world";
    }
  }
}
                </code></pre>
                <p>
                    <small>
                        <a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_testing">
                            https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_testing
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">補充</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">下一步?</p>
                <img data-src="https://i.imgur.com/NuWlebS.png" alt="未來">
                <p>
                    <a href="https://cloud.tencent.com/developer/article/1082825">
                        针对事件驱动架构的Spring Cloud Stream - 云+社区 - 腾讯云
                    </a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Domain-Driven Design</p>
                <img data-src="https://www.books.com.tw/img/F01/277/27/F012772742.jpg" alt="DDD">
                <p>
                    <small>
                        <a href="https://www.books.com.tw/products/F012772742">
                            Implementing Domain-Driven Design
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Event Sourcing & CQRS</p>
                <p>解決分散式交易一致性問題</p>
                <p>追本溯源</p>
                <p>結果無法竄改</p>
                <p>讀寫分別最佳化3</p>
                <aside class="notes">
                    介紹 AXON
                </aside>
            </section>
            <section>
                <p>FB</p>
                <img data-src="https://i.imgur.com/UudkJu4.png" width="40%" alt="FB">
                <p>
                    <small>
                        <a href="https://www.facebook.com/events/2347295052223416">
                            facebook - Domain Driven Design Taiwan 1st MeetUp at 2019
                        </a>
                    </small>
                    <small>
                        <a href="https://www.facebook.com/groups/381051212383902">
                            facebook - Domain Driven Design(Taiwan)
                        </a>
                    </small>

                </p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <p>謝謝指教</p>
            <aside class="notes">
            </aside>
        </section>
    </div>
</div>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        slideNumber: true,
        transition: 'convex', // none/fade/slide/convex/concave/zoom
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>