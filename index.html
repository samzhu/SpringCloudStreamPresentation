<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spring Cloud Stream Presentation</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon"/>
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <link rel="stylesheet" href="css/overrides.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h3 class="em1">Spring Cloud Stream</h3>
            <img height="40%" data-src="https://spring.io/img/homepage/icon-spring-cloud.svg"
                 alt="Down arrow">
            <p>
                Spring Cloud Stream is a framework for building highly scalable event-driven microservices
                connected with shared messaging systems.
            </p>
        </section>
        <section>
            <section>
                <h3 class="em1">自我介紹</h3>
            </section>
            <section>
                <p align="left">朱尚禮 Sam</p>
                <p align="left">twitter:<a href="https://twitter.com/samzhu0318">@samzhu0318</a></p>
                <p align="left">blog:<a href="http://samchu.logdown.com/">SAM的程式筆記</a></p>
                <p align="left"><a href="https://github.com/samzhu">GitHub</a></p>
                <p align="left">2016 Java Community Conference Taiwan Microservice & Cloud Native Speaker</p>
                <p align="left"><a href="https://ithelp.ithome.com.tw/users/20107338/ironman/1445">2018 iT 邦幫忙鐵人賽 -
                    30天從零開始 使用 Spring Boot 跟 Spring Cloud 建構完整微服務架構</a></p>
            </section>
            <section>
                <p>Spring 的愛好使用者</p>
            </section>
            <section>
                <p align="left">第一篇 Spring Boot</p>
                <p align="left">2014年6月17日 <a
                        href="http://samchu.logdown.com/posts/206297-use-spring-boot-to-quickly-build-web-applications">使用Spring-Boot快速建構Web應用</a>
                </p>
                <p align="left">第一篇 Spring Cloud</p>
                <p align="left">2015年11月12日 <a
                        href="http://samchu.logdown.com/posts/313414-microservice-with-springcloud">Microservice with
                    SpringCloud</a></p>
            </section>
            <section>
                <p>On The Spring Blog</p>
                <ul>
                    <li>
                        <a href="https://spring.io/blog/2015/09/16/this-week-in-spring-september-15th-2015-springone2gx-2015-edition">
                            This Chinese-language post on using Quartz with Spring Boot looks amazing
                        </a>
                    </li>
                    <li>
                        <a href="https://spring.io/blog/2015/09/01/this-week-in-spring-september-1-2015">
                            This blog looks at the Spring Cloud configuration server
                        </a>
                    </li>
                    <li>
                        <a href="https://spring.io/blog/2015/08/12/this-week-in-spring-august-11-2015">
                            check out this interesting Chinese-language post on using .yml with Spring Boot
                        </a>
                    </li>
                    <li>
                        <a href="https://spring.io/blog/2017/01/10/this-week-in-spring-january-10th-2017">
                            I liked Sam Chu’s Chinese-language post on setting up multiple MongoDB connections in a Spring application
                        </a>
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">先談一下 Spring</h3>
            </section>
            <section>
                <p class="em2">Spring Design Philosophy</p>
                <p>Provide choice at every level. Spring lets you defer design decisions as late as possible. For
                    example, you can switch persistence providers through configuration without changing your code. The
                    same is true for many other infrastructure concerns and integration with third-party APIs.</p>
                <aside class="notes">
                    提供各個層面的選擇。 Spring允許您盡可能晚地推遲設計決策。 例如，您可以通過配置切換持久性提供程序，而無需更改代碼。 許多其他基礎架構問題以及與第三方API的集成也是如此。
                </aside>
                <p>
                    <small>
                        <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy">
                            https://docs.spring.io/spring/docs/current/spring-framework-reference/overview.html#overview-philosophy
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">實際經驗</p>
                <p>在 NoSQL 異軍突起的年代</p>
                <p>同時要開發 MongoDB, Elasticsearch 數據操作</p>
                <p>還有原本的 RMDB</p>
                <p>一樣是 CRUD 你就必須使用不同 SDK 不同的 API</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/P5AtQNV.jpg" alt="絕望">
            </section>
            <section>
                <p class="em2">Spring Data 出現後</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">JPA</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                        @Entity
                        public class Order{
                            @Id private String orderId;
                            private String billingAddress;
                            private String shippingAddress;
                        }
                    </code>
                    <code class="java" data-trim contenteditable>
                        public interface OrderRepository
                            extends PagingAndSortingRepository< Order, Long > {}
                    </code>
                </pre>
            </section>
            <section>
                <p class="em2">MongoDB</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                        @Document
                        public class Order {
                            @Id private String orderId;
                            private String billingAddress;
                            private String shippingAddress;
                        }
                    </code>
                    <code class="java" data-trim contenteditable>
                        public interface OrderRepository
                            extends PagingAndSortingRepository< Order, Long > {}
                    </code>
                </pre>
            </section>
            <section>
                <p class="em2">Elasticsearch</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                        @Document(indexName = "ec", type = "order")
                        public class Order {
                            @Id private String orderId;
                            private String billingAddress;
                            private String shippingAddress;
                        }
                    </code>
                    <code class="java" data-trim contenteditable>
                        public interface OrderRepository
                            extends PagingAndSortingRepository< Order, Long > {}
                    </code>
                </pre>
            </section>
            <section>
                <p>從此之後我取資料的 API 就只有一種</p>
                <pre>
                    <code class="java" data-trim contenteditable>
                       OrderRepository.getOne()
                    </code>
                </pre>
            </section>
            <section data-background="http://i.giphy.com/90F8aUepslB84.gif">
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">Message Queue</h3>
                <p>訊息佇列是一種行程間通訊或同一行程的不同執行緒間的通訊方式，軟體的貯列用來處理一系列的輸入，通常是來自使用者。</p>
            </section>
            <section>
                <h3 class="em2">Message Queue 有哪些?</h3>
                <p>Apache Kafka, RabbitMQ, Apache ActiveMQ, ZeroMQ, Apache RocketMQ(阿里), Redis, MQTT</p>
            </section>
            <section>
                <p><span>你以為很多了嗎?</span></p>
                <h1><span class="fragment em2" style="font-size: 300px">不</span></h1>
            </section>
            <section>
                <h3 class="em2">還有雲端服務</h3>
                <p>Amazon Kinesis, Google PubSub, Solace PubSub+, Azure Event Hubs</p>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">設計理念不同</h3>
                <p>Kafka 適合做大量 log 收集</p>
                <p>RabbitMQ 中庸 好架設 可以用作聊天系統</p>
                <p>RocketMQ 有保證抵達順序 可以用作交易系統</p>
            </section>
            <section>
                <p class="em2">RabbitMQ</p>
                <p>
                    <small>Topics</small>
                </p>
                <img data-src="https://www.rabbitmq.com/img/tutorials/python-five.png"
                     style="background-color: white"
                     alt="RabbitmqTopics">
                <p>
                    <small>任何發送到 Topic Exchange 的消息都會被轉發到所有關心 RouteKey 中指定話題的 Queue 上</small>
                </p>
                <p>
                    <small>
                        <a href="https://www.rabbitmq.com/getstarted.html">
                            https://www.rabbitmq.com/getstarted.html
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">Kafka</p>
                <img data-src="https://kafka.apache.org/21/images/consumer-groups.png"
                     style="background-color: white"
                     alt="Kafka">
                <p>
                    <small>
                        If all the consumer instances have the same consumer group, then the records will effectively be
                        load balanced over the consumer instances.
                    </small>
                </p>
                <p>
                    <small>
                        <a href="https://kafka.apache.org/documentation/#intro_consumers">
                            https://kafka.apache.org/documentation/#intro_consumers
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">RocketMQ</p>
                <img data-src="https://i.imgur.com/VWMQy8r.png" height="300px"
                     style="background-color: white"
                     alt="RocketMQ">
                <p>
                    <small>
                        用来表示一个消费消息应用，一个Consumer Group下包含多个Consumer实例，可以是多台机器，也可以是多个进程，或者是一个进程的多个Consumer对象。一个Consumer
                        Group下的多个Consumer以均摊方式消费消息，如果设置为广播方式，那么这个Consumer Group下的每个实例都消费全量数据。
                    </small>
                </p>
                <p>
                    <small>
                        <a href="http://flycloud.me/2017/12/04/rocketMQ/rocketMQ%E5%AD%A6%E4%B9%A0/RocketMQ%E5%9F%BA%E7%A1%80/">
                            RocketMQ开发指南
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <h4>假設需要同時使用</h4>
            </section>
            <section>
                <p>但是這三套並不相容, 套件用法也各有不同</p>
                <p>所以你必須同時搞懂三套的 API 用法</p>
                <table>
                    <thead>
                    <tr>
                        <th>MQ</th>
                        <th>Protocol</th>
                        <th>Library</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Kafka</td>
                        <td>自訂RPC</td>
                        <td>kafka-clients-2.1.0.jar</td>
                    </tr>
                    <tr>
                        <td>RabbitMQ</td>
                        <td>AMQP</td>
                        <td>amqp-client-5.5.1.jar</td>
                    </tr>
                    <tr>
                        <td>RocketMQ</td>
                        <td>JMS, MQTT</td>
                        <td>rocketmq-client-4.3.2.jar</td>
                    </tr>
                    </tbody>
                </table>
                <aside class="notes">
                </aside>
            </section>
            <section data-background="https://media.giphy.com/media/YpmVBNubONoqs/giphy.gif">
            </section>
            <section>
                <p>不用再頭痛了</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>要來講 <span class="em2">Spring Cloud Stream</span> 了</p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">Spring Cloud Stream</h3>
                <p>功能與目的 跟 Spring Data 一樣, 由 Spring 來提供更高一階操作, 由各家來實現, 來達成減少我們開發成本.</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Spring Cloud Stream</p>
                <p>
                    <small>The core building blocks of Spring Cloud Stream are:</small>
                </p>
                <ul>
                    <small>
                        <li>Destination Binders: Components responsible to provide integration with the external
                            messaging systems.
                        </li>
                        <li>Destination Bindings: Bridge between the external messaging systems and application provided
                            Producers and Consumers of messages (created by the Destination Binders).
                        </li>
                        <li>Message: The canonical data structure used by producers and consumers to communicate with
                            Destination Binders (and thus other applications via external messaging systems).
                        </li>
                    </small>
                    <p>
                        <small>
                            <a href="https://cloud.spring.io/spring-cloud-stream/">
                                https://cloud.spring.io/spring-cloud-stream/
                            </a>
                        </small>
                    </p>
                </ul>
                <aside class="notes">
                    <p>
                        <small>目標綁定器：負責提供與外部消息傳遞系統集成的組件。</small>
                    </p>
                    <p>
                        <small>目標綁定：外部消息傳遞系統和應用程序之間的橋接消息的生產者和消費者（由目標綁定器創建）。</small>
                    </p>
                    <p>
                        <small>消息：生產者和使用者使用的規範數據結構與目標綁定器（以及通過外部消息傳遞系統的其​​他應用程序）進行通信。</small>
                    </p>
                </aside>
            </section>
            <section>
                <img data-src="https://cloud.spring.io/spring-cloud-stream/img/SCSt-overview.png" height="300px"
                     style="background-color: white"
                     alt="SCSt">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Binder Implementations</p>
                <p>
                    <small>
                        Spring Cloud Stream supports a variety of binder implementations and the following table
                        includes the link to the GitHub projects.
                    </small>
                </p>
                <p>RabbitMQ</p>
                <p>Apache Kafka</p>
                <p>Amazon Kinesis</p>
                <p>Google PubSub (partner maintained)</p>
                <p>Solace PubSub+ (partner maintained)</p>
                <p>Azure Event Hubs (partner maintained)</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>2018.11.16「小马哥技术周报」- 第八期 Spring Cloud Stream Binder Alibaba 实现</p>
                <img data-src="https://i.imgur.com/dgNQ8Zg.png" alt="RocketMQ">
                <p>
                    <small>
                        <a href="https://www.bilibili.com/video/av36114167">
                            bilibili視頻
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">Spring Cloud Stream</h3>
                <p class="em2">sample code</p>
            </section>
            <section>
                <p>dependency</p>
                <pre><code class="xml" data-trim contenteditable>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
        </dependency>
    </dependencies>
                </code></pre>
            </section>
            <section>
                <p class="em2">Producer</p>
            </section>
            <section>
                <p>Producer - application.yml</p>
                <pre><code class="yaml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:    # 因為啟動會發生錯誤, 所以不需要預設的 RabbitTemplate
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        output:    # channelName
          destination: chat.message.v1    # destination，或者可以認為是發布－訂閱模型裏面的topic
          content-type: application/json
          producer:
            required-groups: chatGroup    # 生產者必須確保消息傳遞的組群列表（逗號分隔），即使它們是在創建之後啟動的（例如，通過在RabbitMQ中預先創建持久隊列）。
          binder: eventMq    # 綁定使用的binder
      binders:
        eventMq:
          type: rabbit    # 要使用的 MQ 系統 kafka or 其他等等
          environment:
            spring:
              rabbitmq:
                host: 192.168.56.101
                port: 5672
                </code></pre>
            </section>
            <section>
                <p class="em2">Source.java</p>
                <pre><code class="java" data-trim contenteditable>
package org.springframework.cloud.stream.messaging;

/**
 * Bindable interface with one output channel.
 *
 * @see org.springframework.cloud.stream.annotation.EnableBinding
 * @author Dave Syer
 * @author Marius Bogoevici
 */
public interface Source {

	String OUTPUT = "output";

	@Output(Source.OUTPUT)
	MessageChannel output();

}
                </code></pre>
                <p>
                    <small>
                        <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/messaging/Source.java">
                            Github
                        </a>
                    </small>
                </p>
            </section>
            <section>
                <p class="em2">Producer - DemoApplication.java</p>
                <pre><code class="java" data-trim contenteditable>
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;

@EnableBinding(Source.class)
@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
                </code></pre>
            </section>

            <section>
                <p class="em2">發送消息</p>
                <pre><code class="java" data-trim contenteditable>
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;

@Component
public class ApplicationLoader {
    @Autowired
    private Source source;

    @EventListener(ApplicationReadyEvent.class)
    public void init() {
        Message< String > message = MessageBuilder.withPayload("Hi!!")
                    .build();
        source.output().send(message);
    }
}
                </code></pre>
            </section>
            <section>
                <p class="em2">Consumer</p>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:    # channelName
          destination: chat.message.v1
          content-type: application/json
          binder: eventMq
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 192.168.56.101
                port: 5672
                </code></pre>
                <p>channelName 不一樣</p>
                <aside class="notes">
                    提醒一下 channelName 不一樣
                </aside>
            </section>
            <section>
                <p>Sink.java</p>
                <pre><code class="java" data-trim contenteditable>
package org.springframework.cloud.stream.messaging;

/**
 * Bindable interface with one input channel.
 *
 * @see org.springframework.cloud.stream.annotation.EnableBinding
 * @author Dave Syer
 * @author Marius Bogoevici
 */
public interface Sink {

	String INPUT = "input";

	@Input(Sink.INPUT)
	SubscribableChannel input();

}
                </code></pre>
                <p>
                    <small>
                        <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/main/java/org/springframework/cloud/stream/messaging/Sink.java">
                            Github
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">接收消息</p>
                <pre><code class="java" data-trim contenteditable>
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Component;

@Component
public class ChatReceiver {

    @StreamListener(target = Sink.INPUT)
    public void chatReceive(Message< String > chatMessage) {
        System.out.println("收到: " + chatMessage.getPayload());
    }
}
                </code></pre>
            </section>
            <section>
                <p>測試一下</p>
            </section>
            <section>
                <img data-src="https://i.imgur.com/YwBtOZY.png" alt="測試結果">
            </section>
            <section>
                <h3 class="em2">Done!</h3>
                <img data-src="https://i.imgur.com/viKySyO.jpg" alt="興奮到模糊">
            </section>
            <section>
                <p class="em2">說明一下 Spring 做了什麼</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Exchanges</p>
                <img data-src="https://i.imgur.com/F6gHn6T.png" alt="RabbitMQ Exchanges">
                <aside class="notes">
                    由 Spring 自動建立 Exchange, 也就是我們 yaml 的 destination
                </aside>
            </section>
            <section>
                <p class="em2">Bindings</p>
                <img data-src="https://i.imgur.com/IDht9LV.png" alt="RabbitMQ Bindings">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Queues</p>
                <img data-src="https://i.imgur.com/RHotRbr.png" alt="RabbitMQ Queues">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/fW6obUN.png" style="background-color: white" alt="RabbitMQ Queues">
                <p>Queue chat.message.v1.anonymous.SD0R-ebmRUqPjI-BZsX9Vg 在服務停止後會移除</p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">But</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>人生最厲害就是這個 BUT ！</p>
                <span class="fragment">
                    <img data-src="https://www.books.com.tw/img/001/048/39/0010483921.jpg" alt="九把刀的書">
                    <p>
                        <small>
                            <a href="https://www.books.com.tw/products/0010483921">
                                博客來-人生最厲害就是這個 BUT！
                            </a>
                        </small>
                    </p>
                </span>

                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>多個 Consumer</p>
                <img data-src="https://i.imgur.com/F75LT8U.png" alt="多個 Consumer">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://dvblobcdnjp.azureedge.net//Content/Upload/Popular/Images/2017-06/e99e6b5e-ca6c-4c19-87b7-dfd63db6381a_m.jpg"
                     width="60%" alt="黑人問號">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>重複消費問題</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>問題出在</p>
                <img data-src="https://i.imgur.com/28DXlKl.png" alt="兩個Queue">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/VWdm8s6.png" alt="Exchange到兩個Queue">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/Dx3ydmC.png" style="background-color: white" alt="結構圖">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Spring cloud stream 的解決方法</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Consumer Groups</p>
                <p>
                    <small>
                        While the publish-subscribe model makes it easy to connect applications through shared
                        topics, the ability to scale up by creating multiple instances of a given application is equally
                        important. When doing so, different instances of an application are placed in a competing
                        consumer relationship, where only one of the instances is expected to handle a given message.
                    </small>
                </p>
                <p>
                    <small>
                        Spring Cloud Stream models this behavior through the concept of a consumer group. (Spring
                        Cloud Stream consumer groups are similar to and inspired by Kafka consumer groups.) Each
                        consumer binding can use the spring.cloud.stream.bindings.< channelName >.group property to
                        specify a group name. For the consumers shown in the following figure, this property would be
                        set as spring.cloud.stream.bindings.< channelName >.group=hdfsWrite or
                        spring.cloud.stream.bindings.< channelName >.group=average.
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/images/SCSt-groups.png"
                     alt="spring 解法">
                <p>
                    <small>
                        <a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#consumer-groups">
                            https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#consumer-groups
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:
          destination: chat.message.v1
          content-type: application/json
          group: chatGroup    # 綁定消費組
          binder: eventMq
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 127.0.0.1
                port: 5672
                </code></pre>
                <p>綁定 group</p>
                <aside class="notes">
                    group
                </aside>
            </section>
            <section>
                <h3 class="em2">Done!</h3>
                <img data-src="https://i.imgur.com/ELCpI4x.png" alt="嚇得我目瞪口呆">
            </section>
            <section>
                <p>Exchange</p>
                <img data-src="https://i.imgur.com/zmWEX8K.png" alt="Exchange">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Queue</p>
                <img data-src="https://i.imgur.com/vh6lK9G.png" width="60%" alt="Exchange">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/wGGVIrd.png" style="background-color: white" alt="結構圖">
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">其他功能</h3>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">鏈路追蹤</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>加入</p>
                <pre><code class="xml" data-trim contenteditable>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-sleuth</artifactId>
        </dependency>
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>取得 spanTraceId</p>
                <pre><code class="java" data-trim contenteditable>
    @StreamListener(target = MqChannel.gameChannel)
    public void receiveGameCreateEvent(
            Message GameCreateEvent> eventMessage) {
        log.info("Message spanTraceId={}", eventMessage.getHeaders().get("spanTraceId"));
        log.info("Message spanId={}", eventMessage.getHeaders().get("spanId"));
    }
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>取得 spanTraceId 結果</p>
                <pre><code class="shell" data-trim contenteditable>
2018-12-17 11:31:59.718  INFO [gameservice-v1,2fff644a3967a533,868d7e1a8ca99ff0,false] 2052 --- [.v1.gameGroup-1]
                    c.e.demo.consumer.GameEventReceiver      : Message spanTraceId=2fff644a3967a533
2018-12-17 11:31:59.719  INFO [gameservice-v1,2fff644a3967a533,868d7e1a8ca99ff0,false] 2052 --- [.v1.gameGroup-1]
                    c.e.demo.consumer.GameEventReceiver      : Message spanId=63a6cfa6e68c0253
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">endpoint</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>加入</p>
                <pre><code class="xml" data-trim contenteditable>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>開啟監控 application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
management:
  health:
    binders:
      enabled: true
  endpoints:
    web:
      exposure:
        include: 'channels,bindings,bindings-name'
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>取得 channels 資訊</p>
                <pre><code class="curl" data-trim contenteditable>
curl -X GET http://localhost:7203/actuator/channels
                </code></pre>
                <p></p>
                <pre><code class="json" data-trim contenteditable>
{
    "inputs": {
        "gameChannel": {
            "destination": "game.create.message.v1",
            "group": "gameGroup",
            "binder": "eventMq",
            "consumer": {
                "instanceCount": 1,
                "instanceIndex": 0,
                "maxAttempts": 1
            }
        }
    },
    "outputs": {
        "resultChannel": {
            "destination": "result.message",
            "binder": "eventMq",
            "producer": {
                "requiredGroups": [
                    "webGroup",
                    "resultGroup"
                ]
            }
        }
    }
}
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h3 class="em1">重試</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:    # 因為啟動會發生錯誤, 但是並不需要預設的 RabbitTemplate
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:    # channelName
          destination: chat.message.v1    # destination，或者可以認為是發布－訂閱模型裏面的 topic
          content-type: application/json
          group: chatGroup    # 綁定消費組
          consumer:
            max-attempts: 3    # 默認為 3 次，1 表示禁用重試
          binder: eventMq    # 綁定使用的binder
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 127.0.0.1
                port: 5672
                </code></pre>
                <p>注意 max-attempts 配置</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>重試結果</p>
                <img data-src="https://i.imgur.com/zgJbJrB.png" alt="">
                <aside class="notes">
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h3 class="em1">Dead letter exchanges (DLXs)</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:    # 因為啟動會發生錯誤, 但是並不需要預設的 RabbitTemplate
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:    # channelName
          destination: chat.message.v1    # destination，或者可以認為是發布－訂閱模型裏面的 topic
          content-type: application/json
          group: chatGroup    # 綁定消費組
          consumer:
            max-attempts: 3    # 默認為 3 次，1 表示禁用重試
          binder: eventMq    # 綁定使用的binder
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 127.0.0.1
                port: 5672
      rabbit:
        bindings:
          input:    # 記得一定要對應到 channelName 才有效
            producer:
              auto-bind-dlq: true     # 記得 producer & consumer 兩邊都要配置, 不然會出現綁定錯誤
            consumer:
              auto-bind-dlq: true    # 建立 Exchange: DLX
              republish-to-dlq: true    # 該值為false如果設置了死信隊列，消息對原封不動的發送到死信隊列，如果為true，則消息對帶上錯誤信息發送至死信隊列
#              dlq-ttl: 10000     # 存活時間(毫秒)
                </code></pre>
                <aside class="notes">
                    auto-bind-dlq 記得兩邊都要配置
                </aside>
            </section>
            <section>
                <p>DLX</p>
                <img data-src="https://i.imgur.com/UrH4kI9.png" style="background-color: white" alt="DLX結構圖">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>測試結果</p>
                <img data-src="https://i.imgur.com/qOwjllw.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>建立DLX</p>
                <img data-src="https://i.imgur.com/RUuaVZk.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Routing key</p>
                <img data-src="https://i.imgur.com/Jlpeiah.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Queue</p>
                <img data-src="https://i.imgur.com/JFM3aoA.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Queue chat.message.v1.chatGroup.dlq</p>
                <img data-src="https://i.imgur.com/P21G6U1.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>republish-to-dlq 的功用</p>
                <img data-src="https://i.imgur.com/Oe5Zyqe.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>將錯誤的資訊發出去</p>
                <img data-src="https://i.imgur.com/5mUgkBq.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>死信接收(Rabbit)</p>
                <pre><code class="java" data-trim contenteditable>
@Slf4j
@Component
public class DlqResultReceiverAmqp {
    private static final String ORIGINAL_QUEUE = "chat.message.v1.chatGroup";
    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    @RabbitListener(queues = DLQ)
    public void receiveDLQResult(Message failedMessage) {
        log.info("amqp spanTraceId={}", headers.get("spanTraceId"));
        log.info("amqp spanId={}", headers.get("spanId"));
        log.info("amqp x-exception-message={}", headers.get("x-exception-message"));
        log.info("amqp x-exception-stacktrace={}", headers.get("x-exception-stacktrace"));
        String messageBody = new String(failedMessage.getBody());
        log.info("amqp messageBody={}", messageBody);
    }
}
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h3 class="em1">Condition</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>支援 SpEL </p>
                <pre><code class="java" data-trim contenteditable>
    @StreamListener(target = Processor.INPUT, condition = "headers['eventType']=='gameCreate'")
    public void createGamePlus(
            @Header(name = "username", required = false) String username,
            Message< ResponseData > eventMessage) {
        ResponseData responseDataToWeb = new ResponseData()
                .setCode("0")
                .setMessage(responseData.getGameName() + ", 歡迎 VIP 馬上充值 送好禮!!")
                .setDateTime(LocalDateTime.now());
        Message< ResponseData > responseDataMessage = MessageBuilder.withPayload(responseDataToWeb)
                .setHeader("username", username)
                .build();
    }
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">為 事件驅動 鋪路?</p>
                <img data-src="https://i.imgur.com/NuWlebS.png" alt="未來">
                <p>
                    <a href="https://cloud.tencent.com/developer/article/1082825">
                        针对事件驱动架构的Spring Cloud Stream - 云+社区 - 腾讯云
                    </a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>等下來介紹 事件驅動</p>
                <aside class="notes">
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h3 class="em1">測試</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>
                    <small>可不依賴 RabbitMQ 進行測試</small>
                </p>
                <pre><code class="java" data-trim contenteditable>
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ExampleTest {

  @Autowired
  private Processor processor;

  @Autowired
  private MessageCollector messageCollector;

  @Test
  @SuppressWarnings("unchecked")
  public void testWiring() {
    Message< String> message = new GenericMessage<>("hello");
    processor.input().send(message);
    Message< String> received = (Message< String>) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo("hello world"));
  }


  @SpringBootApplication
  @EnableBinding(Processor.class)
  public static class MyProcessor {

    @Autowired
    private Processor channels;

    @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
    public String transform(String in) {
      return in + " world";
    }
  }
}
                </code></pre>
                <p>
                    <small>
                        <a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_testing">
                            https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_testing
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h3 class="em1">如果我不想直接重試 想讓消息重新排隊呢?</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
spring:
  autoconfigure:
    exclude:    # 因為啟動會發生錯誤, 但是並不需要預設的 RabbitTemplate
    - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  cloud:
    stream:
      bindings:
        input:    # channelName
          destination: chat.message.v1    # destination，或者可以認為是發布－訂閱模型裏面的 topic
          content-type: application/json
          group: chatGroup    # 綁定消費組
          consumer:
            max-attempts: 1    # 默認為 3 次，1 表示禁用重試
          binder: eventMq    # 綁定使用的binder
      binders:
        eventMq:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: 127.0.0.1
                port: 5672
      rabbit:
        bindings:
          input:
            producer:
              auto-bind-dlq: true
            consumer:
              auto-bind-dlq: true    # 建立 Exchange: DLX
#              republish-to-dlq: true    # 無法共用
              requeue-rejected: true    # 消息消費失敗之後，並不會將該消息拋棄，而是將消息重新放入隊列
                </code></pre>
                <aside class="notes">
                    requeue-rejected
                </aside>
            </section>
            <section>
                <p>requeue-rejected</p>
                <p>消息消費失敗之後，並不會將該消息拋棄，而是將消息重新放入隊列</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>重複循環</p>
                <img data-src="https://i.imgur.com/zDWaL1O.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>
                    <small>利用 AmqpRejectAndDontRequeueException</small>
                </p>
                <pre><code class="java" data-trim contenteditable>
@Component
public class ChatReceiver {
    // 放 Redis 之類
    private Map< String, Integer> redis = new HashMap();

    @StreamListener(target = Sink.INPUT)
    public void chatReceive(Message< String> chatMessage) {
        System.out.println(LocalDateTime.now() + " 收到: " + chatMessage.getPayload());
        Integer retries = 0;
        // 這邊應該用雪花算法或是雜湊
        if (redis.get(chatMessage.getPayload()) != null) {
            retries = redis.get(chatMessage.getPayload());
        }
        if (retries == 3) {
            throw new AmqpRejectAndDontRequeueException("tried 3 times failed, send to dlq!");
        } else {
            retries = retries + 1;
            redis.put(chatMessage.getPayload(), retries);
            throw new RuntimeException("Message consumer failed!");
        }
    }
}
                </code></pre>
                <p>
                    <small>
                        <a href="http://blog.didispace.com/spring-cloud-starter-finchley-7-5/">
                            http://blog.didispace.com/spring-cloud-starter-finchley-7-5/
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <img data-src="https://i.imgur.com/t0GP4Dg.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>
                    <small>沒有 republish-to-dlq</small>
                </p>
                <img data-src="https://i.imgur.com/KcEMnct.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>另一種 </p>
                <p>
                    <a href="https://www.e4developer.com/2018/02/05/handling-bad-messages-with-rabbitmq-and-spring-cloud-stream/"></a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>結合 Condition 處理</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <pre><code class="java" data-trim contenteditable>
@Component
public class ChatReceiver {
    @Autowired
    private Processor processor;

    @StreamListener(target = Processor.INPUT, condition = "headers['x-retries'] == null or headers['x-retries'] < 3")
    public void chatReceive(Message< String> chatMessage) {
        System.out.println(LocalDateTime.now() + " 收到: " + chatMessage.getPayload());
        System.out.println(LocalDateTime.now() + " 收到 x-retries: " + chatMessage.getHeaders().get("x-retries"));
        // 假設出錯自己丟回 MQ
        Integer retries = 0;
        if (chatMessage.getHeaders().get("x-retries") != null) {
            retries = (Integer) chatMessage.getHeaders().get("x-retries") + 1;
        }
        Message< String> message = MessageBuilder.withPayload(chatMessage.getPayload())
                .setHeader("x-retries", retries)
                .build();
        processor.output().send(message);
    }

    @StreamListener(target = Processor.INPUT, condition = "headers['x-retries'] >= 3")
    public void chatReceiveDl(Message< String> chatMessage) {
        System.out.println(LocalDateTime.now() + " DLQ 收到: " + chatMessage.getPayload());
        System.out.println(LocalDateTime.now() + " DLQ 收到 x-retries: " + chatMessage.getHeaders().get("x-retries"));
    }
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <pre><code class="shell" data-trim contenteditable>
            2018-12-21T12:12:33.842 收到: Hi!!
            2018-12-21T12:12:33.842 收到 x-retries: null
            2018-12-21T12:12:33.854 收到: Hi!!
            2018-12-21T12:12:33.854 收到 x-retries: 0
            2018-12-21T12:12:33.855 收到: Hi!!
            2018-12-21T12:12:33.855 收到 x-retries: 1
            2018-12-21T12:12:33.857 收到: Hi!!
            2018-12-21T12:12:33.857 收到 x-retries: 2
            2018-12-21T12:12:33.858 DLQ 收到: Hi!!
            2018-12-21T12:12:33.858 DLQ 收到 x-retries: 3
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">ack操作</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Consumer - application.yml</p>
                <pre><code class="yml" data-trim contenteditable>
      rabbit:
        bindings:
          input:
            producer:
              auto-bind-dlq: true
            consumer:
              auto-bind-dlq: true    # 建立 Exchange: DLX
              republish-to-dlq: true    # 該值為false如果設置了死信隊列，消息對原封不動的發送到死信隊列，如果為true，則消息對帶上錯誤信息發送至死信隊列
              acknowledge-mode: MANUAL  # 設定為手動
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <pre><code class="java" data-trim contenteditable>
import com.rabbitmq.client.Channel;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.messaging.Message;
import org.springframework.messaging.handler.annotation.Header;

@Component
public class ChatReceiver {

    @StreamListener(target = Sink.INPUT)
    public void chatReceive(
            Message< String> chatMessage,
            @Header(AmqpHeaders.CHANNEL) Channel channel,
            @Header(AmqpHeaders.DELIVERY_TAG) Long deliveryTag) throws IOException {
        System.out.println(LocalDateTime.now() + " 收到: " + chatMessage.getPayload());
        channel.basicAck(deliveryTag, false);
        /**
         *第一个参数deliveryTag：发布的每一条消息都会获得一个唯一的deliveryTag，deliveryTag在channel范围内是唯一的
         * 第二个参数requeue：表示如何处理这条消息，如果值为true，则重新放入RabbitMQ的发送队列，如果值为false，则通知RabbitMQ销毁这条消息
         */
    }
}
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h3 class="em1">補充</h3>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">事件驅動?</p>
                <img data-src="https://i.imgur.com/NuWlebS.png" alt="未來">
                <p>
                    <a href="https://cloud.tencent.com/developer/article/1082825">
                        针对事件驱动架构的Spring Cloud Stream - 云+社区 - 腾讯云
                    </a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Spring Data 開始有 @DomainEvents ?</p>
                <p>
                    <a href="https://www.baeldung.com/spring-data-ddd">
                        DDD aggregates and @DomainEvents | Baeldung
                    </a>
                </p>
                <p>Spring Cloud Stream 可以用 condition</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Domain-Driven Design</p>
                <img data-src="https://www.books.com.tw/img/F01/277/27/F012772742.jpg" alt="DDD">
                <p>
                    <small>
                        <a href="https://www.books.com.tw/products/F012772742">
                            Implementing Domain-Driven Design
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p class="em2">Event Sourcing & CQRS</p>
                <p>解決分散式交易一致性問題</p>
                <p>追本溯源</p>
                <p>結果無法竄改</p>
                <p>讀寫分別最佳化</p>
                <aside class="notes">
                    介紹 AXON
                </aside>
            </section>
            <section>
                <p>Axon</p>
                <p>
                    <a href="https://www.youtube.com/watch?v=7e5euKxHhTE&t=47s">
                        Bootiful CQRS and Event Sourcing with Axon Framework
                    </a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>FB</p>
                <img data-src="https://i.imgur.com/UudkJu4.png" width="40%" alt="FB">
                <p>
                    <small>
                        <a href="https://www.facebook.com/events/2347295052223416">
                            facebook - Domain Driven Design Taiwan 1st MeetUp at 2019
                        </a>
                    </small>
                    <small>
                        <a href="https://www.facebook.com/groups/381051212383902">
                            facebook - Domain Driven Design(Taiwan)
                        </a>
                    </small>
                </p>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3 class="em1">小小心得分享</h3>
                <aside class="notes">
                    前面講的刻意練習
                </aside>
            </section>
            <section>
                <p>Josh Long</p>
                <img data-src="https://i.imgur.com/0qpZjJZ.png" alt="">
                <p><a href="https://twitter.com/starbuxman">@starbuxman</a></p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>YouTube</p>
                <img data-src="https://i.imgur.com/W5roSze.png" alt="">
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>YouTube</p>
                <p align="left"><a href="https://www.youtube.com/channel/UC7yfnfvEUlXUIfm8rGLwZdA">SpringDeveloper</a>
                </p>
                <p align="left"><a href="https://www.youtube.com/channel/UCLMPXsvSrhNPN3i9h-u8PYg">Spring I/O</a></p>
                <p align="left"><a href="https://www.youtube.com/channel/UCrXb8NaMPQCQkT8yMP_hSkw">Spring Framework
                    Guru</a></p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Spring 官方 blog</p>
                <p align="left"><a href="https://spring.io/blog">https://spring.io/blog</a></p>
                <p align="left">Josh Long 的 This Week in Spring</p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>近期演講</p>
                <p align="left"><a
                        href="https://v.qq.com/x/page/k0782bocg8j.html?fbclid=IwAR3A8VghLpkeTOHAkumqhSfl8Bvrfh8LWQn3c1cM_FXot6WyEEOWyIcLfo4">云原生Spring_腾讯视频</a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>其他網站</p>
                <p align="left">
                    <a href="http://springcloud.cn/">Spring Cloud中国社区</a>
                </p>
                <p align="left">
                    <a href="http://blog.didispace.com/">程序猿DD</a>
                </p>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>謝謝指教</p>
                <p>範例程式</p>
				<p align="left">
                    <a href="https://github.com/samzhu/spring_cloud_stream_demo">https://github.com/samzhu/spring_cloud_stream_demo</a>
                </p>
                <aside class="notes">
                </aside>
            </section>
			<section>
			    <p>辰昇網路科技股份有限公司</p>
                <p>We're hiring.</p>
                <img data-src="https://i.imgur.com/QwQk6vp.png" alt="">
                <aside class="notes">
                </aside>
            </section>
        </section>

    </div>
</div>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        slideNumber: true,
        transition: 'convex', // none/fade/slide/convex/concave/zoom
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>